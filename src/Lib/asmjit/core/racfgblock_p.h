// This file is part of AsmJit project <https://asmjit.com>
//
// See <asmjit/core.h> or LICENSE.md for license and copyright information
// SPDX-License-Identifier: Zlib

#ifndef ASMJIT_CORE_RACFGBLOCK_P_H_INCLUDED
#define ASMJIT_CORE_RACFGBLOCK_P_H_INCLUDED

#include "../core/api-config.h"
#ifndef ASMJIT_NO_COMPILER

#include "../core/compilerdefs.h"
#include "../core/raassignment_p.h"
#include "../core/support_p.h"
#include "../core/zonebitset_p.h"
#include "../core/zonevector.h"

ASMJIT_BEGIN_NAMESPACE

//! \cond INTERNAL
//! \addtogroup asmjit_ra
//! \{

//! Provides a way to mark RABlock instances during processing.
enum class RABlockTimestamp : uint64_t {};

//! Flags used by \ref RABlock.
enum class RABlockFlags : uint32_t {
  //! No flags.
  kNone = 0,

  //! Block has been constructed from nodes.
  kIsConstructed = 0x00000001u,
  //! Block is reachable (set by `buildCFGViews()`).
  kIsReachable = 0x00000002u,
  //! Block is a target (has an associated label or multiple labels).
  kIsTargetable = 0x00000004u,
  //! Block has been allocated.
  kIsAllocated = 0x00000008u,
  //! Block is a function-exit.
  kIsFuncExit = 0x00000010u,

  //! Block is enqueued in a work queue.
  //!
  //! This bit zero between various phases of register allocation, however, some parts can
  //! use it to mark that a block is in a work queue, so it's not added there multiple times.
  kIsEnqueued = 0x00000020u,

  //! Block has a terminator (jump, conditional jump, ret).
  kHasTerminator = 0x00000100u,
  //! Block naturally flows to the next block.
  kHasConsecutive = 0x00000200u,
  //! Block has a jump to a jump-table at the end.
  kHasJumpTable = 0x00000400u,
  //! Block contains fixed registers (pre-colored).
  kHasFixedRegs = 0x00000800u,
  //! Block contains function calls.
  kHasFuncCalls = 0x00001000u
};
ASMJIT_DEFINE_ENUM_FLAGS(RABlockFlags)

//! Basic block used by register allocator pass.
class RABlock {
public:
  ASMJIT_NONCOPYABLE(RABlock)

  //! \name Types
  //! \{

  using PhysToWorkMap = RAAssignment::PhysToWorkMap;
  using WorkToPhysMap = RAAssignment::WorkToPhysMap;

  //! \}

  //! \name Constants
  //! \{

  static inline constexpr uint32_t kLiveIn = 0;
  static inline constexpr uint32_t kLiveOut = 1;
  static inline constexpr uint32_t kLiveKill = 2;
  static inline constexpr uint32_t kLiveCount = 3;

  //! \}

  //! \name Members
  //! \{

  //! Block id (indexed from zero).
  RABlockId _blockId = kBadBlockId;
  //! Block flags, see `Flags`.
  RABlockFlags _flags {};
  //! Timestamp (64-bit) used by block visitors, which can be generated by \ref BaseRAPass::nextTimestamp().
  mutable RABlockTimestamp _timestamp {};

  //! Block predecessors.
  ZoneVector<RABlock*> _predecessors {};
  //! Block successors.
  ZoneVector<RABlock*> _successors {};
  //! Immediate dominator of this block.
  RABlock* _idom {};

  //! First `BaseNode` of this block (inclusive).
  BaseNode* _first {};
  //! Last `BaseNode` of this block (inclusive).
  BaseNode* _last {};

  //! Initial position of this block (inclusive).
  NodePosition _firstPosition {};
  //! End position of this block (exclusive).
  NodePosition _endPosition {};

  //! Post-order view order, used during POV construction.
  uint32_t _povIndex = Globals::kInvalidId;
  //! Shared assignment identifier or `Globals::kInvalidId` if this block doesn't have shared assignment.
  //! See \ref RASharedAssignment for more details.
  uint32_t _sharedAssignmentId = Globals::kInvalidId;

  //! Liveness in/out/kill.
  BitWord* _liveBits {};
  uint32_t _liveBitsSize {};

  //! Basic statistics about registers.
  RARegsStats _regsStats = RARegsStats();
  //! Maximum live-count per register group.
  RALiveCount _maxLiveCount = RALiveCount();

  //! Scratch registers that cannot be allocated upon block entry.
  RegMask _entryScratchGpRegs {};
  //! Scratch registers used at exit, by a terminator instruction.
  RegMask _exitScratchGpRegs {};

  //! Register assignment on entry.
  PhysToWorkMap* _entryPhysToWorkMap = nullptr;

  //! Register allocator pass.
  BaseRAPass* _ra = nullptr;

  //! \}

  //! \name Construction & Destruction
  //! \{

  ASMJIT_INLINE_NODEBUG RABlock(BaseRAPass* ra) noexcept
    : _ra(ra) {}

  //! \}

  //! \name Allocator
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG ZoneAllocator* allocator() const noexcept;

  //! \}

  //! \name CFG Block Identifier and Flags
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RABlockId blockId() const noexcept { return _blockId; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RABlockFlags flags() const noexcept { return _flags; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasFlag(RABlockFlags flag) const noexcept { return Support::test(_flags, flag); }

  ASMJIT_INLINE_NODEBUG void addFlags(RABlockFlags flags) noexcept { _flags |= flags; }
  ASMJIT_INLINE_NODEBUG void clearFlags(RABlockFlags flags) noexcept { _flags &= ~flags; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isAssigned() const noexcept { return _blockId != kBadBlockId; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isConstructed() const noexcept { return hasFlag(RABlockFlags::kIsConstructed); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isReachable() const noexcept { return hasFlag(RABlockFlags::kIsReachable); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isTargetable() const noexcept { return hasFlag(RABlockFlags::kIsTargetable); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isAllocated() const noexcept { return hasFlag(RABlockFlags::kIsAllocated); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isFuncExit() const noexcept { return hasFlag(RABlockFlags::kIsFuncExit); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool isEnqueued() const noexcept { return hasFlag(RABlockFlags::kIsEnqueued); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasTerminator() const noexcept { return hasFlag(RABlockFlags::kHasTerminator); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasConsecutive() const noexcept { return hasFlag(RABlockFlags::kHasConsecutive); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasJumpTable() const noexcept { return hasFlag(RABlockFlags::kHasJumpTable); }

  ASMJIT_INLINE_NODEBUG void makeConstructed(const RARegsStats& regStats) noexcept {
    _flags |= RABlockFlags::kIsConstructed;
    _regsStats.combineWith(regStats);
  }

  ASMJIT_INLINE_NODEBUG void makeReachable() noexcept { _flags |= RABlockFlags::kIsReachable; }
  ASMJIT_INLINE_NODEBUG void makeTargetable() noexcept { _flags |= RABlockFlags::kIsTargetable; }
  ASMJIT_INLINE_NODEBUG void makeAllocated() noexcept { _flags |= RABlockFlags::kIsAllocated; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG const RARegsStats& regsStats() const noexcept { return _regsStats; }

  //! \}

  //! \name CFG Block Nodes
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<RABlock*> predecessors() const noexcept { return _predecessors.as_span(); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<RABlock*> successors() const noexcept { return _successors.as_span(); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasPredecessors() const noexcept { return !_predecessors.empty(); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasSuccessors() const noexcept { return !_successors.empty(); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasSuccessor(const RABlock* block) const noexcept {
    Span<RABlock*> span = successors();
    Span<RABlock*> pred = block->predecessors();

    if (pred.size() < span.size()) {
      span = pred;
      block = this;
    }

    return span.contains(block);
  }

  //! Adds a successor to this block, and predecessor to `successor`, making connection on both sides.
  //!
  //! This API must be used to manage successors and predecessors, never manage it manually.
  [[nodiscard]]
  Error appendSuccessor(RABlock* successor) noexcept;

  //! Similar to `appendSuccessor()`, but does a prepend operation instead of append.
  //!
  //! This function is used to add a natural flow (always first) to the block.
  [[nodiscard]]
  Error prependSuccessor(RABlock* successor) noexcept;

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RABlock* consecutive() const noexcept { return hasConsecutive() ? _successors[0] : nullptr; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RABlock* iDom() noexcept { return _idom; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG const RABlock* iDom() const noexcept { return _idom; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasPovIndex() const noexcept { return _povIndex != Globals::kInvalidId; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG uint32_t povIndex() const noexcept { return _povIndex; }

  //! \}

  //! \name CFG Block Content
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG BaseNode* first() const noexcept { return _first; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG BaseNode* last() const noexcept { return _last; }

  ASMJIT_INLINE_NODEBUG void setFirst(BaseNode* node) noexcept { _first = node; }
  ASMJIT_INLINE_NODEBUG void setLast(BaseNode* node) noexcept { _last = node; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG NodePosition firstPosition() const noexcept { return _firstPosition; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG NodePosition endPosition() const noexcept { return _endPosition; }

  ASMJIT_INLINE_NODEBUG void setFirstPosition(NodePosition position) noexcept { _firstPosition = position; }
  ASMJIT_INLINE_NODEBUG void setEndPosition(NodePosition position) noexcept { _endPosition = position; }

  //! \}

  //! \name CFG Block Timestamp
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RABlockTimestamp timestamp() const noexcept { return _timestamp; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasTimestamp(RABlockTimestamp ts) const noexcept { return _timestamp == ts; }

  ASMJIT_INLINE_NODEBUG void setTimestamp(RABlockTimestamp ts) const noexcept { _timestamp = ts; }

  ASMJIT_INLINE_NODEBUG void resetTimestamp() const noexcept { _timestamp = RABlockTimestamp(0); }

  //! \}

  //! \name Liveness Bits
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE Error alloc_live_bits(size_t size) noexcept {
    size_t bit_word_count = BitOps::size_in_words<BitWord>(size);
    _liveBits = allocator()->zone()->allocZeroed<BitWord>(Support::align_up(bit_word_count * sizeof(BitWord) * kLiveCount, Globals::kZoneAlignment));

    if (ASMJIT_UNLIKELY(!_liveBits)) {
      return DebugUtils::errored(kErrorOutOfMemory);
    }

    _liveBitsSize = uint32_t(bit_word_count);
    return kErrorOk;
  }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<BitWord> liveBits(uint32_t liveId) noexcept { return Span<BitWord>(_liveBits + liveId * _liveBitsSize, _liveBitsSize); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<const BitWord> liveBits(uint32_t liveId) const noexcept { return Span<const BitWord>(_liveBits + liveId * _liveBitsSize, _liveBitsSize); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<BitWord> liveIn() noexcept { return liveBits(kLiveIn); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<const BitWord> liveIn() const noexcept { return liveBits(kLiveIn); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<BitWord> liveOut() noexcept { return liveBits(kLiveOut); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<const BitWord> liveOut() const noexcept { return liveBits(kLiveOut); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<BitWord> kill() noexcept { return liveBits(kLiveKill); }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG Span<const BitWord> kill() const noexcept { return liveBits(kLiveKill); }

  //! \}

  //! \name Register Assignment
  //! \{

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RegMask entryScratchGpRegs() const noexcept;

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG RegMask exitScratchGpRegs() const noexcept { return _exitScratchGpRegs; }

  ASMJIT_INLINE_NODEBUG void addEntryScratchGpRegs(RegMask regMask) noexcept { _entryScratchGpRegs |= regMask; }
  ASMJIT_INLINE_NODEBUG void addExitScratchGpRegs(RegMask regMask) noexcept { _exitScratchGpRegs |= regMask; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasEntryAssignment() const noexcept { return _entryPhysToWorkMap != nullptr; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG PhysToWorkMap* entryPhysToWorkMap() const noexcept { return _entryPhysToWorkMap; }

  ASMJIT_INLINE_NODEBUG void setEntryAssignment(PhysToWorkMap* physToWorkMap) noexcept { _entryPhysToWorkMap = physToWorkMap; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG bool hasSharedAssignmentId() const noexcept { return _sharedAssignmentId != Globals::kInvalidId; }

  [[nodiscard]]
  ASMJIT_INLINE_NODEBUG uint32_t sharedAssignmentId() const noexcept { return _sharedAssignmentId; }

  ASMJIT_INLINE_NODEBUG void setSharedAssignmentId(uint32_t id) noexcept { _sharedAssignmentId = id; }

  //! \}
};

//! \}
//! \endcond

ASMJIT_END_NAMESPACE

#endif // !ASMJIT_NO_COMPILER
#endif // ASMJIT_CORE_RACFGBLOCK_P_H_INCLUDED
